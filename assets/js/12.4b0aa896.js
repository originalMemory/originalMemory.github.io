(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{443:function(e,t,r){"use strict";r.r(t);var a=r(17),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("iOS 项目里引用一个 pod A 时，出现在以二进制形式引用并编译时运行到某个方法调用时会崩溃，以源码形式引用时不会。崩溃原因是 "),r("code",[e._v("EXC_BAD_INSTRUCTION")]),e._v(" ，位置是 A 里调另一个 pod B 的方法。")]),e._v(" "),r("p",[e._v("起初以为是提交的代码有问题，通过二分法定位到了出问题的提交上，尝试分块修改测试，结果所有改动都测完了还是没定位到问题。后面注意到在这个提交里修改了 A 依赖的 B 的版本。从 'x.x.3' 升到了 'x.x.6' ，但是因为主项目里锁定的 B 的版本是 'x.x.13' ，所以最开始的时候以为问题不在这里。")]),e._v(" "),r("p",[e._v("随后尝试了在 B 的版本是 '.3' 和 '.13' 的时候分别打 A 的二进制包尝试，结果都没问题，于是对比起了 B 的源码，发现 '.6' 里调用的方法挪了位置， '.13' 又挪回了原位。A 的二进制包是基于 '.6' 打的，所以在主项目运行时在 '.13' 的 B 里对应位置找不到对应的方法，引发了崩溃。将 A 依赖的 B 的版本升到 '.13' 后重新打包就好了。")]),e._v(" "),r("p",[e._v("后面查资源的时候发现 "),r("code",[e._v("EXC_BAD_INSTRUCTION")]),e._v(" 的含义是 "),r("code",[e._v("usually means you’ve hit a compiler trap, that is, an undefined instruction inserted into the code by the compiler because of a bug detected at runtime.")]),e._v(" ，其实已经提示了原因可能是因为调用的方法没有定义。但是对这个错误接触比较少，没有第一时间想的。而且位置在 '.6' 修改后， '.13' 又改回去了，排查的时候也被这个误导了。")]),e._v(" "),r("h3",{attrs:{id:"参考文章"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考文章"}},[e._v("#")]),e._v(" 参考文章")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://developer.apple.com/forums/thread/65953",target:"_blank",rel:"noopener noreferrer"}},[e._v("Thread 1:EXC_BAD_INSTRUCTION"),r("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=n.exports}}]);