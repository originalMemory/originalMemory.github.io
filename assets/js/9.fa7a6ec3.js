(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{436:function(e,t,r){"use strict";r.r(t);var a=r(17),s=function(e){e.options.__data__block__={mermaid_382ee14b:"graph TD;\n1(开始)\n2(清理旧 Build 数据);\n3(强制所有 plugin 打成静态库);\n4(build realase);\n5(build simulator);\n6(复制 release 数据到输出目录);\n7(lipo 合并 simulator 和输出目录里的二进制架构);\n8(复制 simulator 的 swift module);\n9(合并 swift header);\n10(去除 Flutter.framework 的 bitcode);\n11(更新 统合的 podspec);\n12(上传 repo);\n1--\x3e2;\n2--\x3e3;\n3--\x3e4;\n4--\x3e5;\n5--\x3e6;\n6--\x3e7;\n7--\x3e8;\n8--\x3e9;\n9--\x3e10;\n10--\x3e11;\n11--\x3e12;"}},o=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("Flutter 升 2.0 后 iOS module 升级打包流程记录")]),e._v(" "),r("h2",{attrs:{id:"背景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[e._v("#")]),e._v(" 背景")]),e._v(" "),r("p",[e._v("项目之前引入了 Flutter 来开发其中一个模块，引用方式是把 release 环境下生成的 App.framework 和 Flutter.framework 及所有 plugin 的源码压缩上传，在项目 "),r("code",[e._v("pod install")]),e._v(" 时手动下载并以 dev pod 的方式引用。这样的引用导致主项目不关注的 Flutter 内容被以 dev 方式引用，且需要自己手动管理项目里下载的 Flutter 内容。")]),e._v(" "),r("p",[e._v("近期把项目使用的 Flutter 版本升级了 2.0 ， release 包不再支持 x86 架构，导致在模拟器运行时编译报错。需要对打包和引入方式进行升级。")]),e._v(" "),r("h2",{attrs:{id:"新打包流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#新打包流程"}},[e._v("#")]),e._v(" 新打包流程")]),e._v(" "),r("Mermaid",{attrs:{id:"mermaid_382ee14b",code:e.$dataBlock.mermaid_382ee14b}}),r("h3",{attrs:{id:"新包使用方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#新包使用方法"}},[e._v("#")]),e._v(" 新包使用方法")]),e._v(" "),r("p",[e._v("打包后修改主项目 Podfile 内的 "),r("code",[e._v("pod 'FlutterLib', 'x.x.x'")]),e._v(" 的版本号即可。")]),e._v(" "),r("h2",{attrs:{id:"升级过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#升级过程"}},[e._v("#")]),e._v(" 升级过程")]),e._v(" "),r("h3",{attrs:{id:"修改-build-方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#修改-build-方式"}},[e._v("#")]),e._v(" 修改 build 方式")]),e._v(" "),r("p",[e._v("之前的打包过程中，release 包走的是 "),r("code",[e._v("./flutterw build ios --release --no-codesign")]),e._v(" ，是官方推荐的做法。但 debug 包却是单独只 build bundle ，即只 build 了资源文件， Flutter.framework 和 App.framework 都是从 Flutter 目录里拷贝的，不是现 build 的。")]),e._v(" "),r("p",[e._v("这个流程不合理，统一改为了用 "),r("code",[e._v("./flutterw build ios --{mode} --no-codesign")]),e._v(" 的方式 build release 和 simulator 两份。")]),e._v(" "),r("h3",{attrs:{id:"收集-flutter-和-plugin-的-pod"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#收集-flutter-和-plugin-的-pod"}},[e._v("#")]),e._v(" 收集 flutter 和 plugin 的 pod")]),e._v(" "),r("p",[e._v("开发中引用的一些 plugin 在 iOS 端有相应的 pod ，这部分在打包的时候也需要带进去。")]),e._v(" "),r("p",[e._v("之前的做法是遍历所有的 plugin ，找到 iOS 端的源码，然后全部拷贝到一起，再以 development pod 的方式引用。")]),e._v(" "),r("p",[e._v("因为不期望使用 development pod ，如果用 pod 的方式引入，就需要往 repo 里传一份，并找个仓库存放对应的源码，这样做需要加不少逻辑，同时如果 plugin 有变动，也需要改动主项目的 podfile ，不是一种好做法。")]),e._v(" "),r("p",[e._v("看 build 的结果发现所有 plugin 的 pod 和 App.framework ， Flutter.framework 都在一起，且也被打成了二进制文件，于是决定直接用二进制的方式引用。")]),e._v(" "),r("p",[e._v("flutter build 默认打出来的 plugin pod 是 .a ，不方便直接引用，在 iOS/Podfile 里首行加上 use_framework! 后就能打成 .framework 了。")]),e._v(" "),r("p",[e._v("然后建了 1 个文件夹把 build 后所有的 plugin pod ，App.framework 和 Flutter.framework 都拷贝了过去。")]),e._v(" "),r("p",[e._v("拷贝的时候不能把 build 目录里的文件全部拷贝，因为除了 Runner 本身的 framework 外，引用的一些公共库，如 Mantle 等也在里面，需要从 .flutter_plugins 文件读取 plugins 的列表，再有针对性的复制，同时 FlutterPluginRegistrant 需要单独处理，它不在 .flutter_plugins 里面。")]),e._v(" "),r("h3",{attrs:{id:"生成新的-pod"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生成新的-pod"}},[e._v("#")]),e._v(" 生成新的 pod")]),e._v(" "),r("p",[e._v("新建了一个 FlutterLib.podspec ，通过  "),r("code",[e._v("vendored_frameworks")]),e._v(" 引入了所有的 framework ，主项目引入的时候只需要引入 FlutterLib 即可，不需要再关注 flutter 其他内容变动。")]),e._v(" "),r("p",[e._v("FlutterLib 引入的 framework 目前是都打成了 1 个 zip ，上传到私有仓库。")]),e._v(" "),r("h3",{attrs:{id:"主项目引入"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主项目引入"}},[e._v("#")]),e._v(" 主项目引入")]),e._v(" "),r("p",[e._v("主项目引入 TutorFlutterLib 时，编译报错，Reason: image not found 。原因是因为 Flutter 打包生成的是动态库，导致引用的一些公共库在链接的时候找不到。")]),e._v(" "),r("p",[e._v("起初想通过修改 iOS/Runner 的设置来令所有的 pod 都打成静态库，但是因为 App.framework 和 Flutter.framework 必须打成动态库，一改就会导致打包失败，只能无奈放弃。")]),e._v(" "),r("p",[e._v("最后用了比较 hack 的方法，读取 .flutter_plugins 并遍历所有 plugin pod 的 podspec ，强制加上了 "),r("code",[e._v("s.static_framework = true")]),e._v(" 来保证所有 plugin pod 都是静态库，避免因为依赖公共库导致的编译报错。")]),e._v(" "),r("h3",{attrs:{id:"兼容-simulator-x86-架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#兼容-simulator-x86-架构"}},[e._v("#")]),e._v(" 兼容 simulator x86 架构")]),e._v(" "),r("p",[e._v("先是同时 build 了 release 和 simulator 两套文件，然后先将 release 的结果放到输出目录里去，再通过 lipo 将 simulator 的 framework 内的二进制文件合并到输出结果里去。")]),e._v(" "),r("p",[e._v("本以为这样应该就可以了，结果编译报错，提示找不到 x86 的构架。起初以为是 simulator 打包或者合并二进制的过程出问题了，排查了一阵子后发现这两个都没有问题。")]),e._v(" "),r("p",[e._v("问题出在打包的时候， release 和 simulator 两种模式除了二进制文件外，部分 pod 在 .framework/ambassador.swiftmodule（不是所有的 pod 这里面都有内容） 里也有按架构区分的文件，这部分也要复制过去。")]),e._v(" "),r("p",[e._v("同样有问题的还有 Swift.h 文件，但，而是需要修改 "),r("code",[e._v("Headers/{pod_name}-Swift.h")]),e._v(" ，将 release 和 simulator 的 Swift.h 合并成 1 个，结构如下：")]),e._v(" "),r("div",{staticClass:"language-objc line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-objc"}},[r("code",[r("span",{pre:!0,attrs:{class:"token macro property"}},[r("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),r("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("if")]),e._v(" "),r("span",{pre:!0,attrs:{class:"token expression"}},[e._v("TARGET_OS_SIMULATOR")])]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("simulator 代码"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token macro property"}},[r("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),r("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("else")])]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("release 代码"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),r("span",{pre:!0,attrs:{class:"token macro property"}},[r("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),r("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("endif")])]),e._v("\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br")])]),r("h3",{attrs:{id:"去除-bitcode"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#去除-bitcode"}},[e._v("#")]),e._v(" 去除 bitcode")]),e._v(" "),r("p",[e._v("Flutter 2.0 开始在生成的 Flutter.framework 里会包含 bitcode ，导致体积从几十 M 增加到了几百 M，不便于 pod 的上传和下载。且我们项目对 bitcode 没有需求，故去除了 bitcode 以精简包体积。命令为 "),r("code",[e._v("xcrun bitcode_strip -r {binary_path} -o {output_path}")])]),e._v(" "),r("p",[e._v("bitcode 的相关内容可见 "),r("a",{attrs:{href:"https://juejin.cn/post/6968272595686785031",target:"_blank",rel:"noopener noreferrer"}},[e._v("深入了解iOS中的Bitcode功能"),r("OutboundLink")],1)])],1)}),[],!1,null,null,null);"function"==typeof s&&s(o);t.default=o.exports}}]);